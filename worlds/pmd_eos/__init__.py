from typing import List, Dict, Set, Anyimport osimport jsonfrom .Items import EOS_item_table, EOSItem, item_tablefrom .Locations import EOS_location_table, EOSLocationfrom .Options import EOSOptionsfrom .Rules import set_rulesfrom .Regions import EoS_regionsfrom BaseClasses import Tutorial, ItemClassification, Region, Locationfrom worlds.AutoWorld import World, WebWorldfrom .Client import EoSClientclass EOSWeb(WebWorld):    theme = "ocean"    game = "Pokemon Mystery Dungeon: Explorers of Sky"    tutorials = [Tutorial(        "Multiworld Setup Guide",        "A Guide to setting up Explorers of Sky for MultiWorld.",        "English",        "setup_en.md",        "setup/en",        ["CrypticMonkey33", "Chesyon"]    )]class EOSWorld(World):    """    This is for Pokemon Mystery Dungeon Explorers of Sky, a game where you inhabit a pokemon and explore    through dungeons, solve quests, and help out other Pokemon in the colony    """    game = "Pokemon Mystery Dungeon: Explorers of Sky"    options: EOSOptions    web = EOSWeb()    item_name_to_id = {item.name: item.id for                       item in EOS_item_table}    location_name_to_id = {location.name: location.id for                           location in EOS_location_table}    origin_region_name = "Overworld"    required_client_version = (0, 1, 0)    options_dataclass = EOSOptions    def generate_early(self) -> None:        test = 0    def create_regions(self) -> None:        menu_region = Region("Menu", self.player, self.multiworld)        self.multiworld.regions.append(menu_region)        main_region = Region("Overworld", self.player, self.multiworld)        self.multiworld.regions.append(main_region)        menu_region.connect(main_region)        for location in EOS_location_table:            if location.classification == "DungeonUnlock" or location.classification == "SpecialDungeonUnlock":                main_region.locations.append(EOSLocation(self.player, location.name, location.id, main_region))        boss_region = Region("Boss Room", self.player, self.multiworld)        boss_region.locations.append(EOSLocation(self.player, "Final Boss", None, boss_region))        main_region.connect(boss_region)        self.get_location("Final Boss").place_locked_item(self.create_item("Victory"))    def create_item(self, name: str, classification: ItemClassification = None) -> EOSItem:        item_data = item_table[name]        return EOSItem(item_data.name, item_data.classification, item_data.id, self.player)    def fill_slot_data(self) -> Dict[str, Any]:        return {        }    def create_items(self) -> None:        required_items = []        filler_items = []        for item_name in item_table:            if item_table[item_name].classification == ItemClassification.filler:                filler_items.append( self.create_item(item_name, ItemClassification.filler))            elif item_table[item_name].classification == ItemClassification.useful:                required_items.append(self.create_item(item_name, ItemClassification.useful))            elif item_table[item_name].name == "Victory":                continue            else:                required_items.append(self.create_item(item_name, ItemClassification.progression))        self.multiworld.itempool += required_items    def set_rules(self) -> None:        test = 0        self.multiworld.completion_condition[self.player] = lambda state: state.has("Victory", self.player)